// Copyright (c) .NET Foundation. All rights reserved.
// Licensed under the Apache License, Version 2.0. See License.txt in the project root for license information.

using GitHubVulnerabilities2v3.Configuration;
using GitHubVulnerabilities2V3.Entities;
using Microsoft.Extensions.Logging;
using Newtonsoft.Json;
using NuGet.Protocol;
using NuGet.Services.Cursor;
using NuGet.Services.Entities;
using NuGet.Services.GitHub.Ingest;
using NuGet.Services.Storage;
using Serilog.Core;
using System;
using System.Collections.Generic;
using System.IO;
using System.Linq;
using System.Text;
using System.Threading;
using System.Threading.Tasks;
using System.Windows.Forms;
using static System.Data.Entity.Infrastructure.Design.Executor;

namespace GitHubVulnerabilities2v3.Extensions
{
    public class BlobStorageVulnerabilityWriter : IVulnerabilityWriter
    {
        private readonly GitHubVulnerabilities2v3Configuration _configuration;
        private readonly ReadWriteCursor<DateTimeOffset> _cursor;
        private readonly ILogger _logger;
        private readonly IStorageFactory _storageFactory;

        private RunMode _mode;
        private Dictionary<string, List<Advisory>> _vulnerabilityDict;
        private AzureStorage _storage;

        private string TimeFormat = "yyyy.mm.dd.HH.mm.ss";

        public BlobStorageVulnerabilityWriter(
            IStorageFactory storageFactory,
            GitHubVulnerabilities2v3Configuration configuration,
            ReadWriteCursor<DateTimeOffset> cursor,
            RunMode mode,
            ILogger<BlobStorageVulnerabilityWriter> logger)
        {
            _storageFactory = storageFactory ?? throw new ArgumentNullException(nameof(storageFactory));
            _configuration = configuration ?? throw new ArgumentNullException(nameof(configuration));
            _cursor = cursor ?? throw new ArgumentNullException(nameof(cursor));
            _logger = logger ?? throw new ArgumentNullException(nameof(logger));
            _mode = mode;

            _storage = (AzureStorage)_storageFactory.Create();
        }

        public async Task FlushAsync(string outputFileName = null)
        {
            var stringContentOutput = JsonConvert.SerializeObject(_vulnerabilityDict, Formatting.Indented);

            var basePath = "";
            var updatePath = "";
            StringStorageContent baseContent;
            StringStorageContent updateContent;
            StringStorageContent indexContent;
            var currentTime = DateTime.Now.ToString(TimeFormat);
            var indexUri = _storage.ResolveUri(_configuration.IndexFileName);
            IndexEntry[] indexEntries;

            switch (_mode)
            {
                case RunMode.Update:
                    if (!await _storage.ExistsAsync(indexUri.ToString(), CancellationToken.None))
                    {
                        _logger.LogWarning("Tried to run in Update mode, but {IndexPath} doesn't exist. Falling through to regeneration.", indexUri.ToString());
                        basePath = Path.Combine(currentTime, _configuration.BaseFileName);
                        break;
                    }

                    // Load the index and....
                    var indexStorageContent = await _storage.Load(_storage.ResolveUri(_configuration.IndexFileName), CancellationToken.None);
                    indexEntries = JsonConvert.DeserializeObject<IndexEntry[]>(indexStorageContent.GetContentStream().ToJson());

                    // Scan the index for the base file so we can determine which folder we need to write in for the update.
                    foreach (var entry in indexEntries)
                    {
                        if (entry.Name.Equals("base"))
                        {
                            basePath = entry.Id;
                            break;
                        }
                    }

                    var pathParts = basePath.Split('/');
                    // the folder should always be 2 entries in from the end of the list
                    // Ex: https://api.nuget.org/v3/vulnerabilities/1234.56.78.90.12.34/vulnerability.base.json
                    //                                                   HERE
                    var baseFolder = pathParts[pathParts.Length - 2];

                    updatePath = Path.Combine(baseFolder, currentTime, _configuration.UpdateFileName);

                    for (var i = 0; i < indexEntries.Length; i++)
                    {
                        if (indexEntries[i].Name.Equals("update"))
                        {
                            indexEntries[i].Id = Path.Combine("someROOT", updatePath);
                            indexEntries[i].Updated = DateTime.UtcNow;
                            break;
                        }
                    }

                    updateContent = new StringStorageContent(stringContentOutput, contentType: "application/json", cacheControl: "max-age=604800, must-revalidate");
                    indexContent = new StringStorageContent(JsonConvert.SerializeObject(indexEntries, Formatting.Indented), contentType: "application/json", cacheControl: "max-age=259200, must-revalidate");

                    await _storage.Save(_storage.ResolveUri(updatePath), updateContent, true, CancellationToken.None);
                    await _storage.Save(_storage.ResolveUri(_configuration.IndexFileName), indexContent, true, CancellationToken.None);

                    //Log update run and vulnerability count.
                    break;
                case RunMode.Regenerate:
                    basePath = Path.Combine(currentTime, _configuration.BaseFileName);
                    updatePath = Path.Combine(currentTime, currentTime, _configuration.UpdateFileName);
                    indexEntries = new IndexEntry[] {
                        new IndexEntry
                        {
                            Name="base",
                            Id=Path.Combine("someROOT", basePath),                                          // UPDATE THIS
                            Updated=DateTime.UtcNow,
                            Comment="The base data for vulnerability update periodically"
                        },
                        new IndexEntry
                        {
                            Name="update",
                            Id=Path.Combine("someROOT", updatePath),                                        // UPDATE THIS
                            Updated=DateTime.UtcNow,
                            Comment="The patch data for the vulnerability. Contains all the vulnerabilities since base was last updated."
                        },
                    };

                    baseContent = new StringStorageContent(stringContentOutput, contentType: "application/json", cacheControl: "max-age=604800, must-revalidate");
                    updateContent = new StringStorageContent("{}", contentType: "application/json", cacheControl: "max-age=604800, must-revalidate");

                    // We use a different cache control time here since the if the index is updated, the user needs to see the new file.
                    indexContent = new StringStorageContent(JsonConvert.SerializeObject(indexEntries, Formatting.Indented), contentType: "application/json", cacheControl: "max-age=259200, must-revalidate");

                    await _storage.Save(_storage.ResolveUri(basePath), baseContent, true, CancellationToken.None);
                    await _storage.Save(_storage.ResolveUri(updatePath), updateContent, true, CancellationToken.None);
                    await _storage.Save(_storage.ResolveUri(_configuration.IndexFileName), indexContent, true, CancellationToken.None);

                    _cursor.Value = DateTimeOffset.UtcNow;
                    await _cursor.Save(CancellationToken.None);

                    // log regeneration run and count.
                    break;
                case RunMode.None:
                default:
                    _logger.LogError("RunMode was unable to be determined correctly.");
                    // Throw here. We don't want to break anything.
                    throw new RunModeException();
            }
        }

        public async Task<int> WriteVulnerabilitiesAsync(IEnumerable<Tuple<PackageVulnerability, bool>> vulnerabilities)
        {
            foreach (var vulnerability in vulnerabilities)
            {
                await WriteVulnerabilityAsync(vulnerability.Item1, vulnerability.Item2);
            }

            return 0;
        }

        public async Task WriteVulnerabilityAsync(PackageVulnerability packageVulnerability, bool wasWithdrawn = false)
        {
            try
            {
                foreach (var vulnerableRange in packageVulnerability.AffectedRanges)
                {
                    var idToWrite = vulnerableRange.PackageId.ToLowerInvariant();
                    var advisory = new Advisory
                    {
                        Url = new Uri(packageVulnerability.AdvisoryUrl),
                        Severity = (int)packageVulnerability.Severity,
                        Versions = vulnerableRange.PackageVersionRange
                    };

                    if (!_vulnerabilityDict.ContainsKey(idToWrite))
                    {
                        _vulnerabilityDict.Add(idToWrite, new List<Advisory>());
                    }

                    _vulnerabilityDict[idToWrite].Add(advisory);
                }
            }
            catch (Exception e)
            {
                _logger.LogError("WriteVulnerability Failed for Advisory Url {AdvisoryUrl}", packageVulnerability.AdvisoryUrl);
                throw e;
            }
        }

        private async Task DetermineRunMode()
        {
            if (_mode != RunMode.None)
            {
                return;
            }

            _mode = RunMode.Update;
            await _cursor.Load(CancellationToken.None);
            if (DateTimeOffset.Compare(_cursor.Value.AddDays(30), DateTimeOffset.Now) >= 0)
            {
                _cursor.Value = DateTimeOffset.FromUnixTimeSeconds(0);
                _mode = RunMode.Regenerate;
            }
            await _cursor.Save(CancellationToken.None);
        }
    }
}
