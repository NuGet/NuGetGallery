// Copyright (c) .NET Foundation. All rights reserved.
// Licensed under the Apache License, Version 2.0. See License.txt in the project root for license information.

using GitHubVulnerabilities2v3.Telemetry;
using GitHubVulnerabilities2v3.Configuration;
using GitHubVulnerabilities2v3.Entities;
using Microsoft.Extensions.Logging;
using Newtonsoft.Json;
using NuGet.Protocol;
using NuGet.Services.Cursor;
using NuGet.Services.Entities;
using NuGet.Services.GitHub.Ingest;
using NuGet.Services.Storage;
using System;
using System.Collections.Generic;
using System.IO;
using System.Text;
using System.Threading;
using System.Threading.Tasks;
using System.Linq;

namespace GitHubVulnerabilities2v3.Extensions
{
    public class BlobStorageVulnerabilityWriter : IVulnerabilityWriter
    {
        private static readonly string BASE_ENTRY_NAME = "base";
        private static readonly string UPDATE_ENTRY_NAME = "update";
        private static readonly string TimeFormat = "yyyy.MM.dd.HH.mm.ss";

        private readonly GitHubVulnerabilities2v3Configuration _configuration;
        private readonly ReadWriteCursor<DateTimeOffset> _cursor;
        private readonly ILogger _logger;
        private readonly IStorageFactory _storageFactory;

        private Dictionary<string, List<Advisory>> _vulnerabilityDict;
        private IStorage _storage;
        private ITelemetryService _telemetryService;

        public BlobStorageVulnerabilityWriter(
            IStorageFactory storageFactory,
            GitHubVulnerabilities2v3Configuration configuration,
            ReadWriteCursor<DateTimeOffset> cursor,
            ILogger<BlobStorageVulnerabilityWriter> logger,
            ITelemetryService telemetryService)
        {
            _storageFactory = storageFactory ?? throw new ArgumentNullException(nameof(storageFactory));
            _configuration = configuration ?? throw new ArgumentNullException(nameof(configuration));
            _cursor = cursor ?? throw new ArgumentNullException(nameof(cursor));
            _logger = logger ?? throw new ArgumentNullException(nameof(logger));
            _telemetryService = telemetryService ?? throw new ArgumentNullException(nameof(telemetryService));

            _storage = _storageFactory.Create();
            _vulnerabilityDict = new Dictionary<string, List<Advisory>>(StringComparer.OrdinalIgnoreCase);
        }

        public async Task FlushAsync(string outputFileName = null)
        {
            var runMode = await DetermineRunMode(_cursor);
            StringBuilder sb = new StringBuilder();

            using (StringWriter sw = new StringWriter(sb))
            using (JsonWriter textWriter = new JsonTextWriter(sw))
            {
                var serializer = new JsonSerializer();
                serializer.Serialize(textWriter, _vulnerabilityDict);
                await textWriter.FlushAsync();
            }

            var stringContentOutput = sb.ToString();

            int vulnerabilityCount = 0;
            foreach(var vulnerability in _vulnerabilityDict.Values)
            {
                vulnerabilityCount += vulnerability.Count;
            }

            string basePath = "";
            Uri updateStorageUri;
            StringStorageContent baseContent;
            StringStorageContent updateContent;
            StringStorageContent indexContent;
            var currentTime = DateTime.UtcNow.ToString(TimeFormat);
            var indexStorageUri = _storage.ResolveUri(_configuration.IndexFileName);
            IndexEntry[] indexEntries;
            UriBuilder updateUriBuilder = new UriBuilder(_configuration.V3BaseUrl);
            StringBuilder updateUriPathBuilder = new StringBuilder();
            updateUriPathBuilder.Append(_configuration.V3VulnerabilityContainerName + "/");

            if (runMode == RunMode.Update && !await _storage.ExistsAsync(indexStorageUri.ToString(), CancellationToken.None))
            {
                _logger.LogWarning("Update mode was set, but {IndexPath} doesn't exist. Falling back to regeneration.", indexStorageUri.ToString());
                runMode = RunMode.Regenerate;
            }

            switch (runMode)
            {
                case RunMode.Update:
                    // Load the index and....
                    var indexStorageContent = await _storage.LoadString(indexStorageUri, CancellationToken.None);
                    indexEntries = JsonConvert.DeserializeObject<IndexEntry[]>(indexStorageContent);

                    // Scan the index for the base file so we can determine which folder we need to write in for the update.
                    foreach (var entry in indexEntries)
                    {
                        if (entry.Name.Equals(BASE_ENTRY_NAME))
                        {
                            basePath = entry.Id;
                            break;
                        }
                    }

                    var pathParts = basePath.Split('/');
                    // the folder should always be 2 entries in from the end of the list
                    // Ex: https://api.nuget.org/v3/vulnerabilities/1234.56.78.90.12.34/vulnerability.base.json
                    //                                                   HERE
                    var baseFolder = pathParts[pathParts.Length - 2];

                    // Start special case block
                    var currentBaseContentUri = _storage.ResolveUri(Path.Combine(baseFolder, _configuration.BaseFileName));
                    var currentBaseContent = await _storage.LoadString(currentBaseContentUri, CancellationToken.None);
                    var baseContentObject = JsonConvert.DeserializeObject<Dictionary<string, List<Advisory>>>(currentBaseContent);

                    if (await ShouldRegenerateForSpecialCase(baseContentObject))
                    {
                        _telemetryService.TrackSpecialCaseTrigger();
                        break;
                    }
                    // End special case block

                    updateUriPathBuilder.Append(baseFolder + "/");
                    updateUriPathBuilder.Append(currentTime + "/");
                    updateUriPathBuilder.Append(_configuration.UpdateFileName);
                    updateUriBuilder.Path = updateUriPathBuilder.ToString();

                    updateStorageUri = _storage.ResolveUri(Path.Combine(baseFolder, currentTime, _configuration.UpdateFileName));

                    for (var i = 0; i < indexEntries.Length; i++)
                    {
                        if (indexEntries[i].Name.Equals(UPDATE_ENTRY_NAME))
                        {
                            indexEntries[i].Id = updateUriBuilder.Uri.AbsoluteUri.ToString();
                            indexEntries[i].Updated = DateTime.UtcNow;
                            break;
                        }
                    }

                    updateContent = new StringStorageContent(stringContentOutput, contentType: "application/json", cacheControl: "max-age=604800, must-revalidate");
                    indexContent = new StringStorageContent(JsonConvert.SerializeObject(indexEntries), contentType: "application/json", cacheControl: "max-age=259200, must-revalidate");

                    await _storage.Save(updateStorageUri, updateContent, true, CancellationToken.None);
                    await _storage.Save(indexStorageUri, indexContent, true, CancellationToken.None);

                    _telemetryService.TrackUpdateRun(vulnerabilityCount);
                    break;
                case RunMode.Regenerate:
                    var updatedTime = DateTime.UtcNow;

                    UriBuilder baseUriBuilder = new UriBuilder(_configuration.V3BaseUrl);
                    StringBuilder baseUriPathBuilder = new StringBuilder();
                    baseUriPathBuilder.Append(_configuration.V3VulnerabilityContainerName + "/");
                    baseUriPathBuilder.Append(currentTime + "/");
                    baseUriPathBuilder.Append(_configuration.BaseFileName);
                    baseUriBuilder.Path = baseUriPathBuilder.ToString();

                    var baseStorageUri = _storage.ResolveUri(Path.Combine(currentTime, _configuration.BaseFileName));

                    updateUriPathBuilder.Append(currentTime + "/");
                    updateUriPathBuilder.Append(currentTime + "/");
                    updateUriPathBuilder.Append(_configuration.UpdateFileName);
                    updateUriBuilder.Path = updateUriPathBuilder.ToString();

                    updateStorageUri = _storage.ResolveUri(Path.Combine(currentTime, currentTime, _configuration.UpdateFileName));

                    indexEntries = new IndexEntry[] {
                        new IndexEntry
                        {
                            Name=BASE_ENTRY_NAME,
                            Id=baseUriBuilder.Uri.AbsoluteUri.ToString(),
                            Updated=updatedTime,
                            Comment="The base data for vulnerability update periodically"
                        },
                        new IndexEntry
                        {
                            Name=UPDATE_ENTRY_NAME,
                            Id=updateUriBuilder.Uri.AbsoluteUri.ToString(),
                            Updated=updatedTime,
                            Comment="The patch data for the vulnerability. Contains all the vulnerabilities since base was last updated."
                        },
                    };

                    baseContent = new StringStorageContent(stringContentOutput, contentType: "application/json", cacheControl: "max-age=604800, must-revalidate");
                    updateContent = new StringStorageContent("{}", contentType: "application/json", cacheControl: "max-age=604800, must-revalidate");

                    // We use a different cache control time here since the if the index is updated, the user needs to see the new file.
                    indexContent = new StringStorageContent(JsonConvert.SerializeObject(indexEntries), contentType: "application/json", cacheControl: "max-age=259200, must-revalidate");

                    _logger.LogInformation("Writing {vulnerabilityCount} vulnerabilities and saving.", vulnerabilityCount);

                    await _storage.Save(baseStorageUri, baseContent, true, CancellationToken.None);
                    await _storage.Save(updateStorageUri, updateContent, true, CancellationToken.None);
                    await _storage.Save(indexStorageUri, indexContent, true, CancellationToken.None);

                    _cursor.Value = DateTimeOffset.UtcNow;
                    await _cursor.Save(CancellationToken.None);

                    _telemetryService.TrackRegenerationRun(vulnerabilityCount);
                    break;
                case RunMode.None:
                default:
                    _logger.LogError("RunMode was unable to be determined correctly.");
                    // Throw here. We don't want to break anything.
                    throw new InvalidOperationException();
            }
        }

        public async Task<int> WriteVulnerabilitiesAsync(IEnumerable<Tuple<PackageVulnerability, bool>> vulnerabilities)
        {
            foreach (var vulnerability in vulnerabilities)
            {
                await WriteVulnerabilityAsync(vulnerability.Item1, vulnerability.Item2);
            }

            return vulnerabilities.Count();
        }

        public async Task WriteVulnerabilityAsync(PackageVulnerability packageVulnerability, bool wasWithdrawn)
        {
            try
            {
                foreach (var vulnerableRange in packageVulnerability.AffectedRanges)
                {
                    var idToWrite = vulnerableRange.PackageId.ToLowerInvariant();
                    var advisory = new Advisory
                    {
                        Url = packageVulnerability.AdvisoryUrl,
                        Severity = (int)packageVulnerability.Severity,
                        Versions = vulnerableRange.PackageVersionRange
                    };

                    if (!_vulnerabilityDict.ContainsKey(idToWrite))
                    {
                        _vulnerabilityDict.Add(idToWrite, new List<Advisory>());
                    }

                    _vulnerabilityDict[idToWrite].Add(advisory);
                }
            }
            catch (Exception e)
            {
                _logger.LogError("WriteVulnerability Failed for Advisory Url {AdvisoryUrl}", packageVulnerability.AdvisoryUrl);
                throw;
            }
        }

        public async Task<RunMode> DetermineRunMode(ReadWriteCursor<DateTimeOffset> cursor)
        {
            var mode = RunMode.Update;
            await cursor.Load(CancellationToken.None);
            if (DateTimeOffset.Compare(cursor.Value.AddDays(30), DateTimeOffset.Now) <= 0)
            {
                mode = RunMode.Regenerate;
            }
            return mode;
        }

        public async Task<bool> ShouldRegenerateForSpecialCase(Dictionary<string,List<Advisory>> baseContent)
        {
            /// Currently, if client sees the same vulnerability URL in update and base, it will be displayed twice.
            ///   (Unless everything from version range to package id to vulnerabiltiy URL is the same. In this case only, client can dedupe)
            /// This is undesirable behaviour, but we are tracking to see how much this actually happens.
            /// We will load the current base.json and compare URLs to the update to see if there are repeats
            /// Ideally, once this is resolved, we can simply remove this method and calls in a single piece.
            /// if this method determines we should regenerate, it will update the cursor to unix epoch and end the run.
            /// This way, the next run will pick up regeneration.

            var baseUriHashSet = new HashSet<string>(StringComparer.OrdinalIgnoreCase);

            foreach(var entry in baseContent)
            {
                foreach(var advisory in entry.Value)
                {
                    baseUriHashSet.Add(advisory.Url);
                }
            }

            foreach(var entry in _vulnerabilityDict)
            {
                foreach(var advisory in entry.Value)
                {
                    if (!baseUriHashSet.Add(advisory.Url))
                    {
                        _cursor.Value = DateTimeOffset.MinValue;
                        await _cursor.Save(CancellationToken.None);
                        return true;
                    }
                }
            }

            return false;
        }
    }
}
