// Copyright (c) .NET Foundation. All rights reserved.
// Licensed under the Apache License, Version 2.0. See License.txt in the project root for license information.

using System;
using System.Collections.Generic;
using System.Data.Entity;
using System.Linq;
using System.Threading.Tasks;
using NuGet.Services.Entities;
using NuGet.Versioning;

namespace NuGetGallery
{
    public class PackageVulnerabilityService : IPackageVulnerabilityService
    {
        private readonly IEntitiesContext _entitiesContext;
        private readonly IPackageUpdateService _packageUpdateService;

        public PackageVulnerabilityService(
            IEntitiesContext entitiesContext,
            IPackageUpdateService packageUpdateService)
        {
            _entitiesContext = entitiesContext ?? throw new ArgumentNullException(nameof(entitiesContext));
            _packageUpdateService = packageUpdateService ?? throw new ArgumentNullException(nameof(packageUpdateService));
        }

        public async Task UpdateVulnerabilityAsync(PackageVulnerability vulnerability, bool withdrawn)
        {
            if (vulnerability == null)
            {
                throw new ArgumentNullException(nameof(vulnerability));
            }

            using (var strategy = new SuspendDbExecutionStrategy())
            using (var transaction = _entitiesContext.GetDatabase().BeginTransaction())
            {
                var packagesToUpdate = UpdateVulnerabilityInternal(vulnerability, withdrawn);
                await _entitiesContext.SaveChangesAsync();

                if (packagesToUpdate.Any())
                {
                    await _packageUpdateService.UpdatePackagesAsync(packagesToUpdate.ToList());
                }

                transaction.Commit();
            }
        }

        /// <summary>
        /// Updates the database with <paramref name="vulnerability"/>.
        /// </summary>
        /// <param name="vulnerability">The <see cref="PackageVulnerability"/> to persist in the database.</param>
        /// <param name="withdrawn">Whether or not this vulnerability has been withdrawn.</param>
        /// <param name="packagesToUpdate">The set of <see cref="Package"/>s affected by this operation that should be marked as updated.</param>
        /// <returns>
        /// The set of packages that were updated as part of this operation.
        /// </returns>
        private HashSet<Package> UpdateVulnerabilityInternal(PackageVulnerability vulnerability, bool withdrawn)
        {
            if (vulnerability == null)
            {
                throw new ArgumentNullException(nameof(vulnerability));
            }

            var packagesToUpdate = new HashSet<Package>();

            // Determine if we already have this vulnerability.
            var existingVulnerability = _entitiesContext.Vulnerabilities
                .Include(v => v.AffectedRanges)
                .Include(v => v.AffectedRanges.Select(pv => pv.Packages))
                .SingleOrDefault(v => v.GitHubDatabaseKey == vulnerability.GitHubDatabaseKey);

            if (existingVulnerability == null)
            {
                AddNewVulnerability(vulnerability, withdrawn, packagesToUpdate);
            }
            else
            {
                UpdateExistingVulnerability(vulnerability, withdrawn, existingVulnerability, packagesToUpdate);
            }

            return packagesToUpdate;
        }

        private void AddNewVulnerability(PackageVulnerability vulnerability, bool withdrawn, HashSet<Package> packagesToUpdate)
        {
            // We should add this vulnerability if it is not withdrawn and could affect at least one package.
            // If the vulnerability does not have any vulnerable ranges, it cannot affect any packages.
            // Even if no packages are currently vulnerable to the vulnerability, as long as it has a vulnerable range, 
            // there is at least one package that could be uploaded that would be vulnerable to it.
            if (!withdrawn && vulnerability.AffectedRanges.Any())
            {
                _entitiesContext.Vulnerabilities.Add(vulnerability);
                _entitiesContext.VulnerableRanges.AddRange(vulnerability.AffectedRanges);
                foreach (var newRange in vulnerability.AffectedRanges)
                {
                    ProcessNewVulnerabilityRange(newRange, packagesToUpdate);
                }
            }
        }

        private void UpdateExistingVulnerability(PackageVulnerability vulnerability, bool withdrawn, PackageVulnerability existingVulnerability, HashSet<Package> packagesToUpdate)
        {
            // We already have this vulnerability, so we should update it.
            var vulnerablePackages = existingVulnerability.AffectedRanges.SelectMany(pv => pv.Packages);
            if (withdrawn || !vulnerability.AffectedRanges.Any())
            {
                // If the vulnerability was withdrawn or lost all its ranges, all packages marked vulnerable need to be unmarked and updated.
                packagesToUpdate.UnionWith(vulnerablePackages);
                _entitiesContext.Vulnerabilities.Remove(existingVulnerability);
                _entitiesContext.VulnerableRanges.RemoveRange(existingVulnerability.AffectedRanges);
            }
            else
            {
                if (UpdatePackageVulnerabilityMetadata(vulnerability, existingVulnerability))
                {
                    // If the vulnerability's metadata was updated, all packages marked vulnerable need to be updated.
                    packagesToUpdate.UnionWith(vulnerablePackages);
                }

                UpdateRangesOfPackageVulnerability(vulnerability, existingVulnerability, packagesToUpdate);
            }
        }

        /// <returns>
        /// Whether not the metadata of the existing vulnerability was changed.
        /// </returns>
        private bool UpdatePackageVulnerabilityMetadata(PackageVulnerability vulnerability, PackageVulnerability existingVulnerability)
        {
            var wasUpdated = false;
            if (vulnerability.Severity != existingVulnerability.Severity)
            {
                existingVulnerability.Severity = vulnerability.Severity;
                wasUpdated = true;
            }

            if (vulnerability.ReferenceUrl != existingVulnerability.ReferenceUrl)
            {
                existingVulnerability.ReferenceUrl = vulnerability.ReferenceUrl;
                wasUpdated = true;
            }

            return wasUpdated;
        }

        private void UpdateRangesOfPackageVulnerability(PackageVulnerability vulnerability, PackageVulnerability existingVulnerability, HashSet<Package> packagesToUpdate)
        {
            // Any new ranges in the updated vulnerability need to be added to the database.
            var rangeComparer = new RangeForSameVulnerabilityEqualityComparer();
            var newRanges = vulnerability.AffectedRanges
                .Except(existingVulnerability.AffectedRanges, rangeComparer)
                .ToList();
            _entitiesContext.VulnerableRanges.AddRange(newRanges);
            foreach (var newRange in newRanges)
            {
                newRange.Vulnerability = existingVulnerability;
                existingVulnerability.AffectedRanges.Add(newRange);
                ProcessNewVulnerabilityRange(newRange, packagesToUpdate);
            }

            // Any ranges that are missing from the updated vulnerability need to be removed.
            var missingRanges = existingVulnerability.AffectedRanges
                .Except(vulnerability.AffectedRanges, rangeComparer)
                .ToList();
            _entitiesContext.VulnerableRanges.RemoveRange(missingRanges);
            foreach (var missingRange in missingRanges)
            {
                existingVulnerability.AffectedRanges.Remove(missingRange);
                packagesToUpdate.UnionWith(missingRange.Packages);
            }
        }

        /// <summary>
        /// Iterates through the <see cref="Package"/>s that could be vulnerable to <paramref name="range"/>.
        /// If any of these packages have not been marked vulnerable and should be, mark them vulnerable and add them to <paramref name="packagesToUpdate"/>.
        /// </summary>
        /// <remarks>
        /// It is not possible to query the database to only return packages satisfying the version range, so we must iterate through all <see cref="Package"/>s in the <see cref="PackageRegistration"/>.
        /// </remarks>
        private void ProcessNewVulnerabilityRange(VulnerablePackageVersionRange range, HashSet<Package> packagesToUpdate)
        {
            var versionRange = VersionRange.Parse(range.PackageVersionRange);
            var packages = _entitiesContext.PackageRegistrations
                .Where(pr => pr.Id == range.PackageId)
                .SelectMany(pr => pr.Packages)
                .ToList();

            foreach (var package in packages)
            {
                var version = NuGetVersion.Parse(package.NormalizedVersion);
                var satisfiesVersionRange = versionRange.Satisfies(version);
                if (satisfiesVersionRange)
                {
                    package.Vulnerabilities.Add(range);
                    range.Packages.Add(package);
                    packagesToUpdate.Add(package);
                }
            }
        }

        /// <remarks>
        /// A <see cref="VulnerablePackageVersionRange"/> is equal to another <see cref="VulnerablePackageVersionRange"/> if it has the same
        /// <see cref="PackageVulnerability"/>, <see cref="VulnerablePackageVersionRange.PackageId"/>, and <see cref="VulnerablePackageVersionRange.PackageVersionRange"/>.
        /// We have determined that the <see cref="PackageVulnerability"/> is the same already, so no need to compare it.
        /// </remarks>
        private class RangeForSameVulnerabilityEqualityComparer : IEqualityComparer<VulnerablePackageVersionRange>
        {
            public bool Equals(VulnerablePackageVersionRange x, VulnerablePackageVersionRange y)
            {
                return x?.PackageId == y?.PackageId
                    && x?.PackageVersionRange == y?.PackageVersionRange;
            }

            public int GetHashCode(VulnerablePackageVersionRange obj)
            {
                return Tuple
                    .Create(
                        obj?.PackageId,
                        obj?.PackageVersionRange)
                    .GetHashCode();
            }
        }
    }
}